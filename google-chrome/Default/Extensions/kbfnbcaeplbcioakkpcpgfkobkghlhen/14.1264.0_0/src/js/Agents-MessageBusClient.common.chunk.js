(self.webpackChunk=self.webpackChunk||[]).push([[4943],{67726:(e,t,s)=>{s.d(t,{S:()=>u});var i,n,o,r=e=>{throw TypeError(e)},a=(e,t,s)=>t.has(e)||r("Cannot "+s),l=(e,t,s)=>(a(e,t,"read from private field"),s?s.call(e):t.get(e)),c=(e,t,s)=>t.has(e)?r("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,s),d=(e,t,s,i)=>(a(e,t,"write to private field"),t.set(e,s),s);class u{constructor(e){c(this,i,new DisposableStack),c(this,n,new Map),c(this,o),d(this,o,e)}send(e){l(this,o).send(e)}subscribe(e){const t=new DisposableStack;t.defer((()=>{const t=l(this,n).get(e);null==t||t[Symbol.dispose](),l(this,n).delete(e)}));const s=new DisposableStack;return l(this,n).set(e,s),null!==l(this,o)&&s.use(l(this,o).subscribe(e)),t}connectToServerPort(e){d(this,o,e);for(const[e,t]of l(this,n)){t[Symbol.dispose]();const s=l(this,o).subscribe(e);l(this,n).set(e,s)}}[Symbol.dispose](){l(this,i).dispose()}}i=new WeakMap,n=new WeakMap,o=new WeakMap},71801:(e,t,s)=>{s.d(t,{C:()=>n});var i=s(63655);class n extends i.l{constructor(e){super(e)}}},63655:(e,t,s)=>{s.d(t,{l:()=>ne});var i,n,o,r,a,l,c,d,u,h,p,m,b,v,f,k,g,I,y,w,S,_,P,M,C,W,B,T,x,D,$,j,A,E,O,R,N=s(23537),G=s(57206),V=s(1933),F=s(64673),L=s(83535),Y=Object.defineProperty,z=Object.defineProperties,X=Object.getOwnPropertyDescriptors,Z=Object.getOwnPropertySymbols,K=Object.prototype.hasOwnProperty,q=Object.prototype.propertyIsEnumerable,H=e=>{throw TypeError(e)},J=(e,t,s)=>t in e?Y(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,Q=(e,t)=>{for(var s in t||(t={}))K.call(t,s)&&J(e,s,t[s]);if(Z)for(var s of Z(t))q.call(t,s)&&J(e,s,t[s]);return e},U=(e,t,s)=>t.has(e)||H("Cannot "+s),ee=(e,t,s)=>(U(e,t,"read from private field"),s?s.call(e):t.get(e)),te=(e,t,s)=>t.has(e)?H("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,s),se=(e,t,s,i)=>(U(e,t,"write to private field"),t.set(e,s),s),ie=(e,t,s)=>(U(e,t,"access private method"),s);class ne{constructor(e){var t,s;te(this,m),te(this,i,new DisposableStack),te(this,n),te(this,o),te(this,r),te(this,a),te(this,l,!1),te(this,c,null),te(this,d,ee(this,i).adopt(new Map,(e=>e.clear()))),te(this,u,ee(this,i).adopt(new Map,(e=>e.clear()))),te(this,h,ee(this,i).adopt(new Map,(e=>e.clear()))),te(this,p,ee(this,i).adopt(new Map,(e=>e.clear()))),se(this,n,e.serverPort),se(this,o,null!=(t=e.tracingOptions)?t:{enabled:!1}),se(this,r,e.retainedValueStorage),se(this,a,`${(0,L.v)()}${void 0!==e.name?`(${e.name})`:""}`),ee(this,i).use(null==(s=ee(this,n))?void 0:s.subscribe((e=>ie(this,m,v).call(this,e)))),ee(this,i).defer((()=>{var t;return null==(t=e.retainedValueStorage)?void 0:t.clear()})),void 0!==ee(this,n)&&this.connect()}isConnected(){return!ee(this,l)}waitConnected(){var e,t;return null!=(t=null==(e=ee(this,c))?void 0:e.promise)?t:Promise.resolve()}connect(){var e;if(!ee(this,n))return Promise.resolve();null==(e=ee(this,c))||e.reject(new Error("Connection attempt superseded by a newer one")),se(this,l,!0),ee(this,p).forEach((e=>e.setBufferingEnabled(!0)));const t=`${ee(this,a)}|${(0,L.v)()}`,s=(0,V.B)();return se(this,c,{attempId:t,resolve:()=>{var e;(null==(e=ee(this,c))?void 0:e.attempId)===t&&(se(this,l,!1),se(this,c,null),ee(this,p).forEach((e=>e.setBufferingEnabled(!1))),s.resolve())},reject:e=>{var i;(null==(i=ee(this,c))?void 0:i.attempId)===t&&(se(this,l,!1),se(this,c,null),s.reject(e))},promise:s.promise}),ee(this,n).send({kind:"handshake",id:t,subscriptions:[...ee(this,d).values()].map((e=>({key:e.key,clientId:e.clientId,subscriptionId:e.portId,timestamp:e.timestamp}))),retainedValues:[...ee(this,h).entries()].map((([e,t])=>({key:e,value:t.value,clientId:t.lastWriterClientId,timestamp:t.modifiedTimestamp})))}),s.promise}createPort(e){const t=null==e?void 0:e.name,s=`${ee(this,a)}|${(0,L.v)()}${void 0!==t?`(${t})`:""}`,n=ee(this,i).use(new oe({send:e=>ie(this,m,g).call(this,s,e),notifyDispose:()=>ie(this,m,b).call(this,s),shouldBufferMessages:ee(this,l),tracingOptions:void 0!==(null==e?void 0:e.tracingOptions)?e.tracingOptions:ee(this,o),portId:s}));return ee(this,p).set(s,n),n}[Symbol.dispose](){ee(this,i).dispose()}}i=new WeakMap,n=new WeakMap,o=new WeakMap,r=new WeakMap,a=new WeakMap,l=new WeakMap,c=new WeakMap,d=new WeakMap,u=new WeakMap,h=new WeakMap,p=new WeakMap,m=new WeakSet,b=function(e){const t=ee(this,p).get(e);if(void 0!==t){for(const[t,s]of ee(this,d).entries())s.portId===e&&ie(this,m,P).call(this,e,{kind:"unsubscribe",subscriptionId:t});t[Symbol.dispose](),ee(this,p).delete(e)}},v=function(e){switch(e.kind){case"publish":ie(this,m,k).call(this,e);break;case"handshake-ack":ie(this,m,f).call(this,e)}},f=function(e){var t,s;if((null==(t=ee(this,c))?void 0:t.attempId)===e.id){ee(this,c).resolve();for(const t of e.newerRetainedValues)ee(this,h).set(t.key,{value:t.value,lastWriterClientId:t.clientId,modifiedTimestamp:t.timestamp}),null==(s=ee(this,r))||s.set(t.key,t.value),ie(this,m,W).call(this,{kind:"publish",key:t.key,value:t.value,timestamp:t.timestamp,clientId:t.clientId})}},k=function(e){var t,s;const i=ee(this,h).get(e.key);if(void 0!==i){if(e.timestamp<=i.modifiedTimestamp)return;ee(this,h).set(e.key,{value:e.value,lastWriterClientId:e.clientId,modifiedTimestamp:e.timestamp}),null==(t=ee(this,r))||t.set(e.key,e.value)}if(null==(s=e.route)||!s.includes(ee(this,a)))return void 0!==e.toSubscriptionId?ie(this,m,M).call(this,e):void 0!==e.toClientId?ie(this,m,C).call(this,e):ie(this,m,W).call(this,e)},g=function(e,t){switch(t.kind){case"publish":ie(this,m,I).call(this,t);break;case"subscribe":ie(this,m,w).call(this,e,t);break;case"unsubscribe":ie(this,m,P).call(this,e,t);break;case"handshake":ie(this,m,y).call(this,e,t)}},I=function(e){var t,s,i;const o=ee(this,h).get(e.key);void 0!==o&&e.timestamp>o.modifiedTimestamp?(ee(this,h).set(e.key,{value:e.value,lastWriterClientId:e.clientId,modifiedTimestamp:e.timestamp}),null==(t=ee(this,r))||t.set(e.key,e.value)):void 0!==o&&ie(this,m,C).call(this,{kind:"publish",key:e.key,value:o.value,timestamp:o.modifiedTimestamp,clientId:o.lastWriterClientId,route:[ee(this,a)],toClientId:e.clientId});const l=((e,t)=>z(e,X(t)))(Q({},e),{route:[...null!=(s=e.route)?s:[],ee(this,a)]});void 0!==e.toClientId?ie(this,m,C).call(this,l):ie(this,m,W).call(this,l),null==(i=ee(this,n))||i.send(l)},y=function(e,t){var s,i;const o=ee(this,p).get(e);if(void 0===o)return void(0,N.P)("No port for handshake message",e);for(const s of t.subscriptions)ie(this,m,S).call(this,{key:s.key,portId:e,timestamp:s.timestamp,clientId:s.clientId,subscriptionId:s.subscriptionId});const l=[],c=[];for(const e of t.retainedValues){const t=ee(this,h).get(e.key);void 0!==t&&t.modifiedTimestamp>=e.timestamp?l.push({key:e.key,value:t.value,timestamp:t.modifiedTimestamp,clientId:t.lastWriterClientId}):(ee(this,h).set(e.key,{value:e.value,lastWriterClientId:e.clientId,modifiedTimestamp:e.timestamp}),null==(s=ee(this,r))||s.set(e.key,e.value),c.push({key:e.key,value:e.value,timestamp:e.timestamp,clientId:e.clientId}))}o.outbound({kind:"handshake-ack",id:t.id,newerRetainedValues:l}),null==(i=ee(this,n))||i.send(t);for(const e of c)ie(this,m,W).call(this,{kind:"publish",key:e.key,value:e.value,timestamp:e.timestamp,clientId:e.clientId,route:[ee(this,a)],excludeSubscriptionIds:t.subscriptions.map((e=>e.subscriptionId))})},w=function(e,t){var s;ee(this,d).has(t.subscriptionId)?(0,N.P)("Subscription with this id already exists",t.subscriptionId):(ie(this,m,S).call(this,Q({portId:e},t)),void 0!==t.retain&&ie(this,m,_).call(this,t,t.retain.value,e),null==(s=ee(this,n))||s.send(t))},S=function(e){const t={key:e.key,portId:e.portId,timestamp:e.timestamp,clientId:e.clientId};ee(this,d).set(e.subscriptionId,t);let s=ee(this,u).get(e.key);void 0===s&&(s=new Set,ee(this,u).set(e.key,s)),s.add(e.subscriptionId)},_=function(e,t,s){var i,n,o,l,c;if("write"===(null==(i=e.retain)?void 0:i.kind)&&e.timestamp>(null!=(o=null==(n=ee(this,h).get(e.key))?void 0:n.modifiedTimestamp)?o:Number.MIN_SAFE_INTEGER)&&!(0,F._)(t,null==(l=ee(this,h).get(e.key))?void 0:l.value))ee(this,h).set(e.key,{value:t,lastWriterClientId:e.clientId,modifiedTimestamp:e.timestamp}),null==(c=ee(this,r))||c.set(e.key,t),void 0!==ee(this,p).get(s)&&ie(this,m,W).call(this,{kind:"publish",key:e.key,value:t,timestamp:e.timestamp,clientId:e.clientId,route:[ee(this,a)],excludeSubscriptionIds:[e.subscriptionId]});else{const i=ee(this,h).get(e.key);if(void 0===i)return;void 0!==ee(this,p).get(s)&&!(0,F._)(t,i.value)&&ie(this,m,M).call(this,{kind:"publish",key:e.key,value:i.value,timestamp:i.modifiedTimestamp,clientId:i.lastWriterClientId,route:[ee(this,a)],toSubscriptionId:e.subscriptionId})}},P=function(e,t){var s,i;const o=ee(this,d).get(t.subscriptionId);if(void 0===o)return void(0,N.P)("No subscription with this id",t.subscriptionId);if(o.portId!==e)return void(0,N.P)("Subscription does not belong to this port",t.subscriptionId,e);ee(this,d).delete(t.subscriptionId);const a=ee(this,u).get(o.key);void 0!==a&&(a.delete(t.subscriptionId),0===a.size&&(ee(this,u).delete(o.key),ee(this,h).delete(o.key),null==(s=ee(this,r))||s.delete(o.key))),null==(i=ee(this,n))||i.send(t)},M=function(e){const t=ee(this,d).get(e.toSubscriptionId);if(void 0===t)return void(0,N.P)("No subscription with this id",e.toSubscriptionId);const s=ee(this,p).get(t.portId);void 0!==s?s.outbound(e):(0,N.P)("No port for subscription with this id",e.toSubscriptionId)},C=function(e){const t=ie(this,m,B).call(this,e.key,e.toClientId,void 0);for(const s of t)s.outbound(e)},W=function(e){const t=ie(this,m,B).call(this,e.key,void 0,e.excludeSubscriptionIds);for(const s of t)s.outbound(e)},B=function(e,t,s){const i=new Set,n=ee(this,u).get(e);for(const e of null!=n?n:[]){if(s&&s.includes(e))continue;const n=ee(this,d).get(e);if(void 0===n||void 0!==t&&t!==n.clientId)continue;const o=ee(this,p).get(n.portId);void 0!==o&&i.add(o)}return i};class oe{constructor(e){var t;te(this,E),te(this,T,new DisposableStack),te(this,x),te(this,D),te(this,$,ee(this,T).use(new G.x)),te(this,j,[]),te(this,A),se(this,D,e.send),se(this,A,e.shouldBufferMessages),ee(this,T).defer((()=>e.notifyDispose())),se(this,x,null!=(t=e.tracingOptions)?t:{enabled:!1}),this.portId=e.portId}send(e){ie(this,E,R).call(this,"inbound",e),ee(this,A)&&"handshake"!==e.kind?ee(this,j).push(e):(ie(this,E,O).call(this),ee(this,D).call(this,e))}subscribe(e){const t=new DisposableStack;return ee(this,T).defer((()=>t.dispose())),t.use(ee(this,$).subscribe({next:e,complete:()=>t.dispose()})),t}[Symbol.dispose](){ee(this,T).dispose()}outbound(e){ie(this,E,R).call(this,"outbound",e),ee(this,$).next(e)}setBufferingEnabled(e){se(this,A,e),e||ie(this,E,O).call(this)}}T=new WeakMap,x=new WeakMap,D=new WeakMap,$=new WeakMap,j=new WeakMap,A=new WeakMap,E=new WeakSet,O=function(){if(ee(this,j).length>0){for(const e of ee(this,j))ee(this,D).call(this,e);ee(this,j).length=0}},R=function(e,t){}},64673:(e,t,s)=>{function i(e,t){if(e===t)return!0;if("object"!=typeof e||null===e||"object"!=typeof t||null===t)return!1;if(Array.isArray(e)&&Array.isArray(t))return e.length===t.length&&e.every(((e,s)=>i(e,t[s])));if(Array.isArray(e)!==Array.isArray(t))return!1;const s=Object.keys(e),n=new Set(Object.keys(t));if(s.length!==n.size)return!1;for(const o of s)if(!n.has(o)||!i(e[o],t[o]))return!1;return!0}s.d(t,{_:()=>i})},57780:(e,t,s)=>{s.d(t,{b:()=>o});var i=s(89662),n=s(70512);const o={events:{documentSessionDisposed:(0,i.d)()},state:{activeTabId:(0,n.x)(),"activeDocument/:tabId":(0,n.x)(),"agentsFeatureFlags/:tabId":(0,n.x)(),lastActivePanelAgentId:(0,n.x)(),activePanelAgentId:(0,n.x)()}}},53128:(e,t,s)=>{s.r(t),s.d(t,{DefaultAgentsMessageBusClient:()=>l});var i=s(27902),n=s(99161),o=s(57780),r=s(9486),a=s(77784);class l{constructor(e){this._disposables=new DisposableStack,this._messageBusRouter=this._disposables.use(new r.o({script:e.script,createContentScriptPort:()=>e.messageApi.createPortConnection(n.Tt.messageBusPort),routerName:(0,a.rL)(e.script,e.tabId)})),this.platformBus=this._disposables.use((0,i.kX)({port:this._messageBusRouter.createPort({name:(0,a.wS)(e.script,e.tabId)}),clientId:(0,a.EZ)(e.script,e.tabId),keyPrefix:(0,a.e7)(),protocol:o.b}))}createPort(...e){return this._messageBusRouter.createPort(...e)}[Symbol.dispose](){this._disposables.dispose()}}},9486:(e,t,s)=>{s.d(t,{o:()=>v});var i=s(74822),n=s(21070),o=s(79256),r=s(18519),a=s(71051),l=s(63532),c=s(66878),d=s(36344),u=s(67726),h=s(71801),p=s(39963),m=s(40594),b=s(9621);class v{constructor(e){this._init=e,this._disposables=new DisposableStack,this._logger=m.Y.create("AgentsReconnectingMessageBusRouterClient"),this._telemetry="cs"===this._init.script?(0,p.Tb)().agents.cs():(0,p.Tb)().agents.sidePanel,this._reconnectSubject=new i.x,this._volatileMessageBusServerPort=this._getNewPort(),this._messageBusServerPort=this._disposables.use(new u.S(this._volatileMessageBusServerPort)),this._messageBusContentScriptRouter=this._disposables.use(new h.C({tracingOptions:{enabled:!1,color:"green"},serverPort:this._messageBusServerPort,name:this._init.routerName})),this._disposables.defer((()=>this._volatileMessageBusServerPort[Symbol.dispose]()));let t=0;this._disposables.adopt(this._reconnectSubject.pipe((0,n.z)((()=>{var e,s;return(0,o.P)((()=>{this._logger.info("Reconnecting to message bus server... Attempt #"+ ++t);const e=this._volatileMessageBusServerPort;return this._volatileMessageBusServerPort=this._getNewPort(),this._messageBusServerPort.connectToServerPort(this._volatileMessageBusServerPort),e[Symbol.dispose](),this._messageBusContentScriptRouter.connect()})).pipe((0,r.V)(null!==(e=this._init.reconnectTimeoutMs)&&void 0!==e?e:1e3),(0,a.X)({count:null!==(s=this._init.reconnectMaxAttempts)&&void 0!==s?s:5}),(0,l.b)((()=>{this._logger.info("Reconnected to message bus server"),t=0})),(0,c.K)((e=>(this._telemetry.error("Failed to reconnect to message bus server",e),this._logger.error("Failed to reconnect to message bus server",e),d.E))))}))).subscribe(),(e=>e.unsubscribe()))}createPort(...e){return this._messageBusContentScriptRouter.createPort(...e)}[Symbol.dispose](){this._disposables.dispose()}_getNewPort(){return(0,b.S)(this._init.createContentScriptPort,(()=>this._reconnectSubject.next()),this._telemetry)}}},77784:(e,t,s)=>{function i(){return"agents/@impl"}function n(e){return`agents/${e}`}function o(e,...t){return r(e,...t)}function r(e,...t){return`agents/@impl/${e}${d(t)}`}function a(e,t,...s){return l(e,t,...s)}function l(e,t,...s){return`${n(e)}/${t}${d(s)}`}function c(e,...t){return`agents/${e}${d(t)}`}function d(e){const t=e.filter(Boolean).join("/");return t?`/${t}`:""}s.d(t,{EZ:()=>r,Lu:()=>n,Yx:()=>l,e7:()=>i,rL:()=>c,wS:()=>o,yp:()=>a})},9621:(e,t,s)=>{s.d(t,{S:()=>o});var i=s(74822),n=s(40594);function o(e,t,s){const o=new DisposableStack,r=e();o.defer((()=>{var e;return null===(e=r.removeMessageListeners)||void 0===e?void 0:e.call(r)}));const a=new i.x;return r.onDisconnect((()=>{var e;o.disposed||(null===(e=r.removeMessageListeners)||void 0===e||e.call(r),t())})),r.onMessage((e=>{o.disposed||a.next(e)})),{send:e=>{if(o.disposed)return s.warn("Cannot send message to a disposed BG port"),void n.Y.create("createClientPort").warn("Cannot send message to a disposed BG port");try{r.postMessage(e)}catch(e){s.error("Error sending message to BG port",e),n.Y.create("createClientPort").error("Error sending message to BG port",e)}},subscribe:e=>{if(o.disposed)return s.warn("Cannot subscribe to a disposed BG port"),n.Y.create("createClientPort").warn("Cannot subscribe to a disposed BG port"),new DisposableStack;const t=o.use(new DisposableStack);return t.adopt(a.subscribe(e),(e=>e.unsubscribe())),t},[Symbol.dispose]:()=>o.dispose()}}}}]);